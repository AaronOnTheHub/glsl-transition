{
  "name": "glslify",
  "version": "0.0.1",
  "description": "command line glsl module system builder",
  "main": "index.js",
  "scripts": {
    "test": "node test/index.js"
  },
  "bin": {
    "glslify": "./bin/glslify"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/glslify.git"
  },
  "keywords": [
    "glslify",
    "glsl",
    "module",
    "system",
    "cli"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "preferGlobal": "true",
  "dependencies": {
    "glslify-stream": "0.0.1",
    "nopt": "~2.0.0",
    "glsl-deparser": "0.0.2",
    "glsl-min-stream": "0.0.2",
    "cssauron-glsl": "0.0.0",
    "shortest": "0.0.0",
    "cssauron": "0.0.2",
    "through": "~1.X.X"
  },
  "readme": "# glslify\n\na module system? in my GLSL? unpossible!\n\n```bash\n$ glslify my-module.glsl > output.glsl\n```\n\nglslify is [browserify](https://github.com/substack/node-browserify) for GLSL.\n\nit allows you to write GLSL modules that export a local function, variable, or type,\nand `require` those modules to bring that export into another module.\n\nlookups work like node's `require` -- that is, it'll work relatively to the file first,\nand then work from the file's directory on up to the root directory looking for a package\nin `node_modules/`.\n\noutput is plain GLSL -- so you'll need to run [exportify](https://github.com/substack/exportify)\non them to use them with browserify.\n\n```c\n// main.glsl\nprecision highp float;\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#pragma glslify: program_one = require(./file1)\n#pragma glslify: program_two = require(./file2, local_value=resolution.x)\n\nint modulo(float x, float y) {\n  return int(x - y * floor(x / y));\n}\n\nvoid main(void) {\n  ivec2 m = ivec2(modulo(gl_FragCoord.x, 2.), modulo(gl_FragCoord.y, 2.));\n\n  if(m.x == 0 || m.y == 0) {\n    program_one();\n  } else { \n    program_two();\n  }\n}\n```\n\n```c\n// file1.glsl\nvoid main(void) {\n  gl_FragColor = vec4(1., 0., 0., 1.);\n}\n\n#pragma glslify: export(main)\n```\n\n```c\n// file2.glsl\n\nuniform float local_value;\n\nvoid main(void) {\n  gl_FragColor = vec4(0., 0., local_value, 1.);\n}\n\n#pragma glslify: export(main)\n```\n# GLSL API\n\nGLSLify works by mangling top-level identities in non-root modules.\n\nExported variables will be aliased on requirement.\n\n### \\#pragma glslify: VARIABLE = require(MODULE[, NAME=EXPR])\n\nImport a module and assign it the name `VARIABLE` in the local program.\n\n`MODULE` may be located within `node_modules/` or relative to the current file.\n\n**Quotes are not allowed.**\n\nIf the target module defines `attribute`, `varying`, or `uniform` global variables,\nyou may map those to a local definition or expression:\n\n```c\n\nattribute vec4 position;\n#pragma glslify: x = require(./takes_vec2, module_variable=position.xy)\n\n```\n\nIf a mapping is not defined, those requirements are forwarded on to the module requiring\nthe current module -- if no mappings are found for a definition, an error is raised.\n\n### \\#pragma glslify: export(NAME)\n\nExports a local name from the current module. If the current module is the root, this is\na no-op. There may be only one exported `NAME` per module. The `NAME` may represent a\ntype, function, or variable.\n\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chrisdickinson/glslify/issues"
  },
  "_id": "glslify@0.0.1",
  "_from": "glslify@~0.0.1"
}
